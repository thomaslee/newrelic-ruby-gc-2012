<!doctype html>  
<html lang="en">
	
	<head>
		<meta charset="utf-8">
		
		<title>Down the rb_newobj() rabbit hole</title>

		<script src="js/jquery.min.js"></script>

		<meta name="description" content="A framework for easily creating beautiful presentations using HTML">
		<meta name="author" content="Hakim El Hattab">

		<meta name="apple-mobile-web-app-capable" content="yes" />
		<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
		
		<link href='http://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
		
		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/newrelic.css" id="theme">

		<!-- For syntax highlighting -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- If the query includes 'print-pdf', use the PDF print sheet -->
		<script>
			document.write( '<link rel="stylesheet" href="css/print/' + ( window.location.search.match( /print-pdf/gi ) ? 'pdf' : 'paper' ) + '.css" type="text/css" media="print">' );
		</script>

		<!--[if lt IE 9]>
		<script src="lib/js/html5shiv.js"></script>
		<![endif]-->
	</head>
	
	<body>
		
		<div class="reveal">

			<!-- Used to fade in a background when a specific slide state is reached -->
			<div class="state-background"></div>
			
			<!-- Any section element inside of this container is displayed as a slide -->
			<div class="slides">
				<section>
                    <h1><small>Down the</small> rb_newobj() <small>Rabbit Hole</small></h1>
                    <h3>Garbage Collection in Ruby</h3>

                    <img src="NewRelic_inline.png" class="logo">

                    <aside class="notes">
                        This is the part where I say "I'm Tom" and you say ...

                        Ruby is changing rapidly ... Ruby 1.9.4-p194
                    </aside>
				</section>
				
                <section>
                    <h1>Chapter 1</h1>
                    <h2>Garbage Collection Fundamentals</h2>
                    <img src="NewRelic_inline.png" class="logo">
                </section>

                <section>
                    <h2><strong>Why</strong> Garbage Collection?</h2>
                    <p style="margin-top: 5em">Because <strong>malloc()</strong> &amp; <strong>free()</strong> are hurty.</p>
                </section>

                <section>
                    <h2>What does a garbage collector <strong>do</strong>, exactly?</h2>
                    <p style="margin-top: 3em"><em>Find memory that can be <strong>safely reclaimed</strong>.</em></p>
                    <p>Then keel-haul it.</p>
                    <p>(Yarr, etc.)</p>
                    <aside class="notes">
                        Think about what to say here. What's the point of this slide?
                    </aside>
                </section>

                <section>
                    <h2>How do they <strong>work</strong>? (<strong>Algorithms</strong>)</h2>
                    <p>Reference counting</p>
                    <p><strong>Mark-sweep</strong></p>
                    <p>... and lots more, plus variants.</p>
                    <p>(See Wilson's <a href="https://ritdml.rit.edu/bitstream/handle/1850/5112/PWilsonProceedings1992.pdf">Uniprocessor GC Techniques</a>)</p>
                    <aside class="notes">
                        You might argue that reference counting isn't a true garbage collection algorithm,
                        since we still need to manually inc &amp; dec reference counts.

                        Start out with the way these work, then dig into caveats.
                        
                        Don't forget the advantages of reference counting!

                        Don't spend too much time on this -- move on to chapter 2.
                    </aside>
                </section>

                <section>
                    <h1>Chapter 2</h1>
                    <h2>Generalized <strong>Mark-Sweep</strong> Algorithm</h2>
                    <img src="NewRelic_inline.png" class="logo">
                </section>

                <section>
                    <h2>Some <strong>Terminology</strong></h2>
                    <p>&quot;Allocated&quot; objects : the <strong>live set</strong>.</p>
                    <p>&quot;Unallocated&quot; objects : the <strong>free set</strong>.</p>
                    <p>&quot;Well-known&quot; reachable objects : the <strong>root set</strong>.</p>
                    <p>We want the <strong>unreachable subset</strong> of the <strong>live set</strong> ...</p>
                    <p>... so we can move 'em to the <strong>free set</strong>.</p>

                    <aside class="notes">
                        Make it more explicit that you're talking about a DAG.
                    </aside>
                </section>

                <section>
                    <h2>Step 1: <strong>Mark</strong></h2>
                    <p>Assume the <em>entire live set</em> starts out <strong>unmarked</strong>.</p>
                    <p>Start by <strong>marking</strong> the <strong>root set</strong></p>
                    <p>(foo-&gt;marked = TRUE)</p>
                    <p>Then mark the objects <em>referenced by</em> the root set ...</p>
                    <p>... and the objects referenced by <em>those</em> objects ...</p>
                    <p>... etc. etc. etc.</p>
                </section>

                <section>
                    <h2>Step 2: <strong>Sweep</strong></h2>
                    <p style="margin-top: 1em">Walk the set of live objects (the <strong>live set</strong>)</p>
                    <p>(N.B. <strong>&quot;live&quot;</strong> and <strong>&quot;reachable&quot;</strong> are not the same thing!)</p>
                    <p><strong>Unmarked objects are not reachable</strong>!</p>
                    <p>Move <em>unmarked objects</em> to the <strong>free set</strong>.</p>

                    <aside class="notes">
                    </aside>
                </section>

                <section>
                    <h1>Chapter 3</h1>
                    <h2>Mark-sweep in <strong>Ruby 1.9.3-p194</strong></h2>
                    <img src="NewRelic_inline.png" class="logo">
                </section>

                <section>
                    <h2><strong>Mark-sweep</strong> in Ruby: An Overview</h2>
                    <p style="margin-top: 2em">Collections are triggered by <strong>allocation</strong>.</p>
                    <p>(or on-demand via calls to <strong>GC.collect</strong>)</p>
                    <p><strong>Mark</strong> is <em>very similar</em> to what's described in <a href="#/7">Chapter 2</a></p>
                    <p>The <strong>sweep</strong> is a little weirder.</p>
                    <p>More on that soon.</p>

                    <aside class="notes">
                        "It's very easy to think of garbage collection happening in a vacuum..."

                        (irb) class Foo; end
                        (gdb) p rb_const_get(rb_cObject, rb_intern("Foo"))
                        (gdb) break rb_obj_alloc if klass == rb_const_get(rb_cObject, rb_intern("Foo"))

                        rb_newobj() calls gc_lazy_sweep().
                        lazy_sweep() walks one slot at a time, moving objects to the free list.
                        if the free list has data at the end of a slot, return true
                        gc_marks() does the marking (called *after* lazy_sweep ... not sure why)
                    </aside>
                </section>

                <section>
                    <h2>More (<strong>Ruby-centric</strong>) Terminology</h2>
                    <p style="margin-top: 3em">Object Spaces</p>
                    <p>&quot;The Heap&quot;</p>
                    <p>Slots</p>
                </section>

                <section>
                    <h2>Terminology: <strong>Object Spaces</strong></h2>
                    <p style="margin-top: 1em">Containers for <strong>GC state &amp; profiling</strong> and <strong>the heap</strong>.</p>
                    <p>Can be either <strong>shared</strong> or <strong>per-VM</strong>.</p>
                    <p>Defaults to shared on <strong>Windows</strong>, per-VM elsewhere.</p>
                    <p>Not to be confused with the <strong>ObjectSpace</strong> <em>module</em> ...</p>
                    <p>... although it's probably obvious how they relate.</p>
                    <aside class="notes">
                        More detail needed! slots etc.
                    </aside>
                </section>

                <section>
                    <h2>Terminology: <strong>The Heap</strong></h2>
                    <p style="margin-top: 1em">Record-keeping data structure for GC allocations.</p>
                    <p>Tracks the <strong>live set</strong>, <strong>free set</strong>, &amp; related stats.</p>
                    <p><strong>One heap</strong> per Object Space.</p>
                    <p><strong>Grows &amp; shrinks</strong> as needed.</p>
                    <p>Broken into <em>heap_length</em> <strong>slabs</strong> of <em>HEAP_SIZE</em> bytes.</p>
                    <p>Each slab divided into <em>HEAP_OBJ_LIMIT</em> <strong>slots</strong>.</p>
                    <aside class="notes">
                        Talk about slots: heap slots can be used.
                    </aside>
                </section>

                <section>
                    <h2>Foo#new &rarr; ??? &rarr; <strong>rb_newobj()</strong>!</h2>
                    <p style="margin-top: 1em">Say you have a class called <strong>Foo</strong></p>
                    <p>Call <strong>Foo.new</strong>. You eventually hit <strong>rb_newobj()</strong></p>
                    <p>How this happens is a presentation in itself.</p>
                    <p>This time around, I'll &quot;prove it&quot; with <strong>gdb</strong>.</p>
                    <p style="color: #666"># TODO more presentationating</p>

                    <aside class="notes">
                        For those of you unfamiliar with Ruby ...
                        I know that I'm doing a bit of hand-waving here ...
                    </aside>
                </section>

                <section>
                    <h2>rb_newobj()</h2>
                    <h3>The heart of object allocation in Ruby</h3>
                    <p style="margin-top: 3em">Allocate one new <strong>uninitialized Ruby object</strong>.</p>
                    <p>Lots going on.</p>
                    <p>I'll try to stick the the important stuff.</p>
                </section>

                <section>
                    <h2><strong>Lazy</strong> Sweeps</h2>
                    <p style="margin-top: 2em"><strong>Deviation</strong> from generalized mark-sweep.</p>
                    <p>Prefers to <strong>recycle the free list</strong> to a lazy sweep.</p>
                    <p>(This is the fastest execution path)</p>
                    <p>If the free list is empty, sweep <em>incrementally</em>.</p>
                </section>
			</div>

			<!-- The navigational controls UI -->
			<aside class="controls">
				<a class="left" href="#">&#x25C4;</a>
				<a class="right" href="#">&#x25BA;</a>
				<a class="up" href="#">&#x25B2;</a>
				<a class="down" href="#">&#x25BC;</a>
			</aside>

			<!-- Presentation progress bar -->
			<div class="progress"><span></span></div>
			
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.min.js"></script>
        <!--
        <script src="js/d3.v2.min.js"></script>
        -->

		<script>
			
			// Full list of configuration options available here:
			// https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				controls: true,
				progress: true,
				history: true,
				
				theme: Reveal.getQueryHash().theme || 'newrelic', // available themes are in /css/theme
				transition: Reveal.getQueryHash().transition || 'page', // default/cube/page/concave/linear(2d)

				// Optional libraries used to extend on reveal.js
				dependencies: [
					{ src: 'lib/js/highlight.js', async: true, callback: function() { window.hljs.initHighlightingOnLoad(); } },
					{ src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
					{ src: 'lib/js/showdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: 'lib/js/data-markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
					{ src: '/socket.io/socket.io.js', async: true, condition: function() { return window.location.host === 'localhost:1947'; } },
					{ src: 'plugin/speakernotes/client.js', async: true, condition: function() { return window.location.host === 'localhost:1947'; } }
				]
			});
			
		</script>

	</body>
</html>
